<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE stax SYSTEM "stax.dtd">
<!--
 ! CDDL HEADER START
 !
 ! The contents of this file are subject to the terms of the
 ! Common Development and Distribution License, Version 1.0 only
 ! (the "License").  You may not use this file except in compliance
 ! with the License.
 !
 ! You can obtain a copy of the license at
 ! trunk/opends/resource/legal-notices/OpenDS.LICENSE
 ! or https://OpenDS.dev.java.net/OpenDS.LICENSE.
 ! See the License for the specific language governing permissions
 ! and limitations under the License.
 !
 ! When distributing Covered Code, include this CDDL HEADER in each
 ! file and include the License file at
 ! trunk/opends/resource/legal-notices/OpenDS.LICENSE.  If applicable,
 ! add the following below this CDDL HEADER, with the fields enclosed
 ! by brackets "[]" replaced with your own identifying information:
 !      Portions Copyright [yyyy] [name of copyright owner]
 !
 ! CDDL HEADER END
 !
 !      Portions Copyright 2006-2007 Sun Microsystems, Inc.
 ! -->
<stax>
  <function name="checkRC">
    <function-prolog>
      This function checks a return code against an expected return code
    </function-prolog>
    
    <function-map-args>
      <function-arg-def name="returncode" type="required">
        <function-arg-description>
          return code received from command
        </function-arg-description>
        <function-arg-property name="type" value="integer"/>
      </function-arg-def>   
      <function-arg-def name="result" type="required">
        <function-arg-description>
          the output of the result
        </function-arg-description>
        <function-arg-property name="type" value="integer"/>
      </function-arg-def>          
      <function-arg-def name="expected" type="optional" default="0">
        <function-arg-description>
          the expected return code
        </function-arg-description>
        <function-arg-property name="type" value="integer"/>
      </function-arg-def>
    </function-map-args>

    <sequence>
      <if expr="returncode == expected">
        <sequence>
          <if expr="result == ''">
            <message log="1">
              'RC=%s, Result=Ok' % (returncode)
            </message>
          <else>
            <message log="1">
              'RC=%s, Result=%s' % (returncode,result)
            </message>
          </else>
          </if>
        </sequence>
        <else>
          <sequence>
            <message log="1" level="'Error'">
              'RC=%s, Expected %s, Result=%s' % (returncode,expected,result)
            </message>
          </sequence>
        </else>
      </if>
      
      <return>RC</return>
      
    </sequence>
  </function>

  <function name="checktestRC">
    <function-prolog>
      This function checks the return code against an expected return code for a testcase
    </function-prolog>
    <function-map-args>
      <function-arg-def name="returncode" type="required">
        <function-arg-description>
          return code received from command
        </function-arg-description>
        <function-arg-property name="type" value="integer"/>
      </function-arg-def>   
      <function-arg-def name="result" type="required">
        <function-arg-description>
          the output of the result
        </function-arg-description>
        <function-arg-property name="type" value="integer"/>
      </function-arg-def>          
      <function-arg-def name="expected" type="optional" default="0">
        <function-arg-description>
          the expected return code
        </function-arg-description>
        <function-arg-property name="type" value="integer"/>
      </function-arg-def>
    </function-map-args>  
    <sequence>
      <if expr="returncode == expected">
        <sequence>
          <tcstatus result="'pass'"/>
          <message log="1">
            'RC=%s, Result=%s' % (returncode,result)
          </message>
        </sequence>
        <else>
          <sequence>
            <tcstatus result="'fail'"/>
            <message log="1" level="'Error'">
              'RC=%s, Expected %s, Result=%s' % (returncode,expected,result)
            </message>
          </sequence>
        </else>
      </if>
    </sequence>
  </function>

  <function name="checktestString">
    <function-prolog>
      This function checks the return string against an expected return substring for a testcase
    </function-prolog>
    
    <function-map-args>
      <function-arg-def name="expectedString" type="required">
        <function-arg-description>
          the substring expected from the command
        </function-arg-description>
        <function-arg-property name="type" value="string"/>
      </function-arg-def>   
      <function-arg-def name="returnString" type="required">
        <function-arg-description>
          the return string received from command
        </function-arg-description>
        <function-arg-property name="type" value="string"/>
      </function-arg-def>          
    </function-map-args>
    
    <sequence>
      <script> 
        searchre = re.compile('%s' % expectedString)
      </script> 

      <if expr='re.search(searchre, returnString) != None'>
        <sequence>
          <tcstatus result="'pass'"/>
          <message log="1">
            'Found substring, %s, in the return string' % (expectedString)
          </message>
        </sequence>
        <else>
          <sequence>
            <tcstatus result="'fail'"/>
            <message log="1" level="'Error'">
              'Did not find substring, %s, in the return string, %s' % (expectedString, returnString)
            </message>
          </sequence>
        </else>
      </if>
    </sequence>
  </function>

  <function name="checktestStringNotPresent">
    <function-prolog>
      This function checks the return string against an expected return substring that should not be present for a testcase
    </function-prolog>
    <function-map-args>
      <function-arg-def name="testString" type="required">
        <function-arg-description>
          the substring being tested from the command
        </function-arg-description>
        <function-arg-property name="type" value="string"/>
      </function-arg-def>   
      <function-arg-def name="returnString" type="required">
        <function-arg-description>
          the return string received from command
        </function-arg-description>
        <function-arg-property name="type" value="string"/>
      </function-arg-def>          
    </function-map-args>

    <sequence>
      <script>
        searchre = re.compile('%s' % testString)
      </script>
      <if expr='re.search(searchre, returnString) == None'>
        <sequence>
          <tcstatus result="'pass'"/>
          <message log="1">
            'Did Not Find substring, %s, in the return string' % (testString)
          </message>
        </sequence>
        <else>
          <sequence>
            <tcstatus result="'fail'"/>
            <message log="1" level="'Error'">
              'Found substring, %s, in the return string, %s' % (testString, returnString)
            </message>
          </sequence>
        </else>
      </if>
    </sequence>
  </function>

  <function name="searchStringForSubstring">
    <function-prolog>
      This function simply searches a string for a substring
    </function-prolog>
    
    <function-map-args>
      <function-arg-def name="testString" type="required">
        <function-arg-description>
          the substring being tested from the command
        </function-arg-description>
        <function-arg-property name="type" value="string"/>
      </function-arg-def>   
      <function-arg-def name="returnString" type="required">
        <function-arg-description>
          the return string received from command
        </function-arg-description>
        <function-arg-property name="type" value="string"/>
      </function-arg-def>
    </function-map-args>

    <sequence>
      <script>
        searchre = re.compile(testString)
      </script>
      <if expr='re.search(searchre, returnString) == None'>
        <sequence>
          <script>returnCode='0'</script>
          <message log="1">
            'Did Not Find substring, %s, in the return string' % (testString)
          </message>
        </sequence>
        <else>
          <sequence>
            <script>returnCode='1'</script>
            <message log="1">
              'Found substring, %s, in the return string' % (testString)
            </message>
          </sequence>
        </else>
      </if>
      <return>returnCode</return>
    </sequence>
  </function>
  
  <function name="isAlive" scope="local">
    <function-prolog>
      Checks that the ldap server is running
    </function-prolog>
    <function-map-args>
      <function-arg-def name="location" type="optional" default="'%s' % STAF_REMOTE_HOSTNAME">
        <function-arg-description>
          Location of target host
      </function-arg-description>
      <function-arg-property name="type" value="hostname"/>
      </function-arg-def>
      <function-arg-def name="dsPath" type="optional" default="'%s/%s' % (DIRECTORY_INSTANCE_DIR,OPENDSNAME)">
        <function-arg-description>
          Pathname to installation root
        </function-arg-description>
        <function-arg-property name="type" value="pathname"/>
      </function-arg-def>
      <function-arg-def name="noOfLoops" type="required">
        <function-arg-description>
          Number of iterations
        </function-arg-description>
        <function-arg-property name="type" value="integer"/>
      </function-arg-def>      
      <function-arg-def name="noOfMilliSeconds" type="required">
        <function-arg-description>
          Number of seconds to wait between iterations
        </function-arg-description>
        <function-arg-property name="type" value="seconds"/>
      </function-arg-def>
      <function-arg-def name="dsInstanceHost" type="optional" default="'%s' % DIRECTORY_INSTANCE_HOST">
        <function-arg-description>
          Directory server hostname or IP address
        </function-arg-description>
        <function-arg-property name="type" value="hostname"/>
      </function-arg-def>      
      <function-arg-def name="dsInstancePort" type="optional" default="'%s' % DIRECTORY_INSTANCE_PORT">
        <function-arg-description>
          Directory server port number
        </function-arg-description>
        <function-arg-property name="type" value="Port number"/>
      </function-arg-def>
      <function-arg-def name="dsInstanceDn" type="optional" default="'%s' % DIRECTORY_INSTANCE_DN">
        <function-arg-description>
          Bind DN
        </function-arg-description>
        <function-arg-property name="type" value="DN"/>
      </function-arg-def> 
      <function-arg-def name="dsInstancePswd" type="optional" default="'%s' % DIRECTORY_INSTANCE_PSWD">
        <function-arg-description>
          Bind password
        </function-arg-description>
        <function-arg-property name="type" value="string"/>
      </function-arg-def>      
    </function-map-args>
      
    <sequence>
      <!-- Local variables -->
      <script>
        mylocation=location
        mypath=dsPath
        myhost=dsInstanceHost
        myport=dsInstancePort
        mydn=dsInstanceDn
        mypswd=dsInstancePswd
      </script>
    
      <script>ldapRC=9999</script>
      <loop from="1" to="noOfLoops" while="ldapRC != 0">
        <sequence>
          <call function="'SearchObject'">
            { 'location'       : mylocation,
              'dsPath'         : mypath,
              'dsInstanceHost' : myhost ,
              'dsInstancePort' : myport ,
              'dsInstanceDn'   : mydn ,
              'dsInstancePswd' : mypswd ,
              'dsScope'        : 'base' ,
              'dsBaseDN'       : 'cn=config' ,
              'dsFilter'	   : 'objectclass=*' }
          </call>

          <script>
            ldapRC=RC
          </script>

          <call function="'Sleep'">
            { 'sleepForMilliSeconds'  : noOfMilliSeconds }
          </call>
          
        </sequence>
      </loop>
      
    </sequence>
  </function>

  <function name="Sleep">
    <function-prolog>
      Sleep for number of milliseconds
    </function-prolog>
    <function-map-args>
      <function-arg-def name="location" type="optional" default="'%s' % STAXServiceMachine">
        <function-arg-description>
          Location of target host
      </function-arg-description>
      <function-arg-property name="type" value="hostname"/>
      </function-arg-def>    
      <function-arg-def name="sleepForMilliSeconds" type="required">
        <function-arg-description>
          Number of milliseconds to sleep
        </function-arg-description>
        <function-arg-property name="type" value="seconds"/>
      </function-arg-def>
    </function-map-args>
    
    <sequence>
      <stafcmd name="'STAF Command: Delay'">
        <location>'%s' % location</location>
        <service>'delay'</service>
        <request>
          'delay %i' % sleepForMilliSeconds
        </request>
      </stafcmd>

      <call function="'checkRC'">
        { 'returncode' : RC ,
          'result'     : STAFResult }
      </call>
    </sequence>
  </function>

  <function name="setOSvariables">
    <function-prolog>
      Set OS related variables
    </function-prolog>
    <function-map-args>
      <function-arg-def name="hostname" type="required">
        <function-arg-description>
          Name of host on which to retrieve variables
        </function-arg-description>
        <function-arg-property name="type" value="hostname"/>
      </function-arg-def>
    </function-map-args>
    <sequence>
      <stafcmd name="'STAF Command: Get OS Name'">
        <location>'%s' % hostname</location>
        <service>'var'</service>
        <request>
          'get system var STAF/Config/OS/Name'
        </request>
      </stafcmd>
      <message>
        'OS Name= %s' % STAFResult
      </message>
      <return>STAFResult</return>
    </sequence>
  </function>

  <function name="testCase_StartBanner">
    <function-prolog>
      Pretty prints a banner at the start of a test.
    </function-prolog>
    <function-no-args />
    <sequence>
      <message>
        '### Starting test case %s. ###' % STAXCurrentTestcase
      </message>
    </sequence>
  </function>

  <function name="testCase_EndBanner">
    <function-prolog>
      Pretty prints a banner at the end of a test.
    </function-prolog>
    <function-no-args />
    <sequence>
      <message>
        '### Ending test case %s. ###' % STAXCurrentTestcase
      </message>
    </sequence>
  </function>

  <function name="testCase_Preamble">
    <function-prolog>
      Performs all the preoperations for a test case
    </function-prolog>
    <function-no-args />
      <sequence>
        <call function="'testCase_StartBanner'" />
    </sequence>
  </function>

  <function name="testCase_Postamble">
    <function-prolog>
      Performs all the post operations for a test suite
    </function-prolog>
    <function-no-args />
    <sequence>

      <!-- Check the SignalRaised flag -->    
      <if expr="SignalRaised">
        <sequence>
          <message>
            'A signal (%s) was raised during this test case' % SignalRaised
          </message>
          <tcstatus result="'fail'"/>
        </sequence>
      </if>

      <!-- Reset the SignalRaised flag -->
      <script>
        SignalRaised='' 
      </script>

      <!-- Query the test case results -->            
      <call function="'queryTestcase'" />
      
      <script>
        if STAFResult.has_key('numPasses'):
          numPass=int(STAFResult['numPasses'])
        else:
          numPass=int(0)
          
        if STAFResult.has_key('numFails'):
          numFail=int(STAFResult['numFails'])
        else:
          numFail=int(0)
      </script>
             
      <if expr="numFail &gt; 0">
        <message>'## Test Verdict: FAIL ##'</message>
      <else>
        <message>'## Test Verdict: PASS ##'</message>
      </else>
      </if>    
      
      <call function="'testCase_EndBanner'" />
    </sequence>
  </function>

  <function name="testSuite_Preamble">
    <function-prolog>
      Performs all the pre operations for a test suite
    </function-prolog>
    <function-no-args />
    <sequence>

      <!-- Take the values from the current test path -->     
      <script>
        if not CurrentTestPath.has_key('group'):
          CurrentTestPath['group']='unknown-group'
                   
        if not CurrentTestPath.has_key('suite'):
          CurrentTestPath['suite']='unknown-suite'
          
        ThisGroupName=CurrentTestPath['group']  
        ThisSuiteName=CurrentTestPath['suite']
      </script>

      <!-- Start time of test suite -->      
      <script>
        TestSuiteStartTime=strftime("%Y%m%d@%H:%M:%S",localtime())
      </script>
          
      <message>
        '#### %s/%s suite preamble ####' % (ThisGroupName,ThisSuiteName)
      </message>
        
    </sequence>
  </function>

  <function name="testSuite_Postamble">
    <function-prolog>
      Performs all the post operations for a test suite
    </function-prolog>
    <function-no-args />
    <sequence>
    
      <!-- Take the values from the current test path -->     
      <script>
        if CurrentTestPath.has_key('suite'):
          ThisSuiteName=CurrentTestPath['suite']
        else:
          ThisSuiteName='unknown-suite'
          
        if CurrentTestPath.has_key('group'):
          ThisGroupName=CurrentTestPath['group']
        else:
          ThisGroupName='unknown-group'
      </script>
    
      <message>
        '#### %s/%s suite postamble ####' % (ThisGroupName,ThisSuiteName)
      </message>

      <!-- Start time of test suite -->      
      <script>
        TestSuiteEndTime=strftime("%Y%m%d@%H:%M:%S",localtime())
      </script>
      
      <!-- Format the test group and suite names to create folder -->
      <script>        
        FormattedTestcase=format_testcase()
        FormattedTestgroup=FormattedTestcase.group(ThisGroupName)         
        FormattedTestsuite=FormattedTestcase.suite(ThisSuiteName)
             
        TestLogDir= '%s/%s' % (logsTestsDir,FormattedTestgroup)
        TestLogFile='%s/%s' % (TestLogDir,FormattedTestsuite) 
      </script>
                  
      <call function="'WriteLogsForTestCase'">
        { 'starttime' : TestSuiteStartTime,
          'endtime'   : TestSuiteEndTime,
          'tofile'    : TestLogFile }
      </call>

      <script>
        if CurrentTestPath.has_key('suite'):
           del CurrentTestPath['suite']
      </script>
              
    </sequence>
  </function>

  <function name="testGroup_Preamble">
    <function-prolog>
      Performs all the pre operations for a test group
    </function-prolog>
    <function-no-args />
    <sequence>
    
      <!-- Take the values from the current test path -->     
      <script>
        if not CurrentTestPath.has_key('group'):
          CurrentTestPath['group']='unknown-group'
        
        ThisGroupName=CurrentTestPath['group']          
      </script>
      
      <message>'##### %s group preamble #####' % ThisGroupName</message>
      
    </sequence>
  </function>

  <function name="testGroup_Postamble">
    <function-prolog>
      Performs all the post operations for a test group
    </function-prolog>
    <function-no-args />
    <sequence>
    
      <script>
        if CurrentTestPath.has_key('group'):
          ThisGroupName=CurrentTestPath['group']
        else:
          ThisGroupName='unknown-group'
      </script>
      
      <message>'##### %s group postamble #####' % ThisGroupName</message>
      
      <script>
        if CurrentTestPath.has_key('group'):
          del CurrentTestPath['group']
      </script>
      
    </sequence>
  </function>
  
  <function name="WriteLogsForTestCase">

    <function-prolog>
      Queries the staf logs for the test case and write to file as text
    </function-prolog>
    <function-map-args>
      <function-arg-def name="starttime" type="required">
        <function-arg-description>
          timestamp to start logging from
        </function-arg-description>
        <function-arg-property name="type" value="timestamp"/>
      </function-arg-def>   
      <function-arg-def name="endtime" type="required">
        <function-arg-description>
          timestamp to start logging to
        </function-arg-description>
        <function-arg-property name="type" value="timestamp"/>
      </function-arg-def>
      <function-arg-def name="tofile" type="required">
        <function-arg-description>
          name of file to write the logs
        </function-arg-description>
        <function-arg-property name="type" value="filepath"/>
      </function-arg-def>                
    </function-map-args>

    <sequence>

      <call function="'queryLogs'">
        { 'location'  : STAXServiceMachine,
          'logname'   : 'STAX_Job_%s_User' % STAXJobID, 
          'startfrom' : starttime,
          'endat'     : endtime }
      </call>

      <call function="'WriteLogs'">
        { 'queryresult' : STAFResult, 
          'logfile'     : tofile }
      </call>

    </sequence>

  </function>

  <function name="WriteLogs">

    <function-prolog>
      Process staf log query results and write them to a file
    </function-prolog>
    <function-map-args>
      <function-arg-def name="queryresult" type="required">
        <function-arg-description>
          result of the staf log query
        </function-arg-description>
        <function-arg-property name="type" value="string"/>
      </function-arg-def>   
      <function-arg-def name="logfile" type="required">
        <function-arg-description>
          name of the log file to where results are written
        </function-arg-description>
        <function-arg-property name="type" value="string"/>
      </function-arg-def>          
    </function-map-args>
    
    <sequence>

      <message>'Creating test log %s' % logfile</message>
     
      <script>
        NewLogDir=posixpath.dirname(logfile)
      </script>
      
      <call function="'createFolder'">
        { 'location'   : STAXServiceMachine, 
          'foldername' : NewLogDir }
      </call>

      <script>
        testlogfh=open(logfile,'w')
      </script>
           
      <iterate var="element" in="queryresult">
        <script>
          level=element['level'] 
          message=element['message']
          timestamp=element['timestamp']

          testlogfh.write('%s %s %s\n' % (timestamp,level,message))
        </script>

      </iterate>

      <script>testlogfh.close()</script>

    </sequence>

  </function>

</stax>
